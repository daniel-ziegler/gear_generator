<html>
<head>
<title>Gear Puzzle</title>
<style type="text/css">
body {
    margin: 0;
    padding: 0;
    background-color: #1a1a2e;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
}
canvas {
    background-color: #16213e;
}
#controls {
    position: fixed;
    top: 10px;
    left: 10px;
    background: rgba(0,0,0,0.7);
    padding: 15px;
    border-radius: 8px;
    color: #fff;
    font-family: monospace;
    z-index: 100;
}
#controls label {
    display: block;
    margin-bottom: 10px;
}
#controls input[type="range"] {
    width: 150px;
    margin-left: 10px;
}
</style>
</head>
<body>
<div id="controls">
    <label>Sun Speed: <span id="sunVal">1.00</span>
        <input type="range" id="sunSlider" min="-2" max="2" step="0.05" value="1">
    </label>
    <label>Carrier Speed: <span id="carrierVal">-0.25</span>
        <input type="range" id="carrierSlider" min="-1" max="1" step="0.05" value="-0.25">
    </label>
</div>
<canvas id="gear_canvas" width="800" height="800"></canvas>

<script src="gear_math.js"></script>
<script>
// Graphics library
var graphics = {
    component_to_hex: function(c) {
        var hex = Math.floor(c).toString(16);
        return hex.length == 1 ? "0" + hex : hex;
    },

    rgb_to_hex: function(r, g, b) {
        return "#" + this.component_to_hex(r) + this.component_to_hex(g) + this.component_to_hex(b);
    },

    init: function(canvas, bounds) {
        var gctx = {
            canvas: canvas,
            context: canvas.getContext("2d"),
            width: canvas.width,
            height: canvas.height,
            bounds: bounds,
            colour: this.rgb_to_hex(0,0,0)
        };
        return gctx;
    },

    clear: function(gctx) {
        gctx.context.fillStyle = '#16213e';
        gctx.context.fillRect(0, 0, gctx.canvas.width, gctx.canvas.height);
    },

    color: function(gctx, r, g, b) {
        gctx.colour = this.rgb_to_hex(r, g, b);
    },

    map_point: function(gctx, pnt) {
        var scaleX = gctx.width / (gctx.bounds[1] - gctx.bounds[0]);
        var scaleY = gctx.height / (gctx.bounds[3] - gctx.bounds[2]);
        var scale = Math.min(scaleX, scaleY);
        var worldWidth = gctx.bounds[1] - gctx.bounds[0];
        var worldHeight = gctx.bounds[3] - gctx.bounds[2];
        var offsetX = (gctx.width - worldWidth * scale) / 2;
        var offsetY = (gctx.height - worldHeight * scale) / 2;
        return [offsetX + (pnt[0] - gctx.bounds[0]) * scale,
                offsetY + (pnt[1] - gctx.bounds[2]) * scale];
    },

    circle: function(gctx, center, rad) {
        var cen = this.map_point(gctx, center);
        var edge = this.map_point(gctx, [center[0] + rad, center[1]]);
        var r = edge[0] - cen[0];
        gctx.context.beginPath();
        gctx.context.arc(cen[0], cen[1], r, 0, 2 * Math.PI);
        gctx.context.strokeStyle = gctx.colour;
        gctx.context.stroke();
    },

    fillCircle: function(gctx, center, rad) {
        var cen = this.map_point(gctx, center);
        var edge = this.map_point(gctx, [center[0] + rad, center[1]]);
        var r = edge[0] - cen[0];
        gctx.context.beginPath();
        gctx.context.arc(cen[0], cen[1], r, 0, 2 * Math.PI);
        gctx.context.fillStyle = gctx.colour;
        gctx.context.fill();
    },

    text: function(gctx, center, txt, size) {
        var cen = this.map_point(gctx, center);
        var edge = this.map_point(gctx, [center[0] + size, center[1]]);
        var fontSize = (edge[0] - cen[0]) * 1.5;
        gctx.context.font = 'bold ' + fontSize + 'px Arial';
        gctx.context.fillStyle = gctx.colour;
        gctx.context.textAlign = 'center';
        gctx.context.textBaseline = 'middle';
        gctx.context.fillText(txt, cen[0], cen[1]);
    },

    polyline: function(gctx, pnts, close) {
        gctx.context.fillStyle = gctx.colour;
        gctx.context.strokeStyle = '#0f0f23';
        gctx.context.lineWidth = 1;
        gctx.context.beginPath();
        var p = this.map_point(gctx, pnts[0]);
        gctx.context.moveTo(p[0], p[1]);
        for(var i = 1; i < pnts.length; i++) {
            p = this.map_point(gctx, pnts[i]);
            gctx.context.lineTo(p[0], p[1]);
        }
        gctx.context.closePath();
        gctx.context.fill();
        gctx.context.stroke();
    }
};

// Gears library
var gears = {
    point_radius: function(pnt) {
        return Math.sqrt(pnt[0]*pnt[0] + pnt[1]*pnt[1]);
    },

    rotate_point: function(cen, pnt, theta) {
        var tpnt = [pnt[0]-cen[0], pnt[1]-cen[1]];
        var c = Math.cos(theta), s = Math.sin(theta);
        return [c*tpnt[0] + s*tpnt[1] + cen[0], -s*tpnt[0] + c*tpnt[1] + cen[1]];
    },

    involute_point: function(r, theta) {
        return [r*(Math.cos(theta)+theta*Math.sin(theta)),
                -r*(Math.sin(theta)-theta*Math.cos(theta))];
    },

    involute_bisect: function(r_base, r_target) {
        var theta_lo = 0.0, theta_hi = Math.PI;
        for(var i = 0; i < 20; i++) {
            var theta_mi = (theta_lo + theta_hi) / 2.0;
            var r_mi = this.point_radius(this.involute_point(r_base, theta_mi));
            if(r_mi <= r_target) theta_lo = theta_mi;
            else theta_hi = theta_mi;
        }
        return (theta_lo + theta_hi) / 2.0;
    },

    involute_curve: function(r_base, r_min, r_max, N) {
        var theta_hi = this.involute_bisect(r_base, r_max);
        var curve = [];
        if(r_min < r_base) curve.push([r_min, 0]);
        var dtheta = theta_hi / (N - 1);
        for(var i = 0; i < N; i++) {
            curve.push(this.involute_point(r_base, i * dtheta));
        }
        return curve;
    },

    generate: function(module, pressure_angle, num_teeth) {
        var Rp = module * num_teeth / 2.0;
        var Rb = Rp * Math.cos(pressure_angle);
        var Rd = Rp - 1.2 * module;
        var Ra = Rp + 1.0 * module;
        var t = Math.PI * Rp / num_teeth;

        var p_cross = this.involute_point(Rb, this.involute_bisect(Rb, Rp));
        var theta_cross = Math.atan2(p_cross[1], p_cross[0]);
        var dtheta = t / Rp;

        var tmp = this.involute_curve(Rb, Rd, Ra, 20);
        var involute = [];
        for(var i = 0; i < tmp.length; i++) {
            var tpnt = this.rotate_point([0,0], tmp[i], theta_cross - dtheta/2);
            if(Math.atan2(tpnt[1], tpnt[0]) < Math.PI/num_teeth && tpnt[1] > 0) {
                involute.push([tmp[i][0], tmp[i][1]]);
            }
        }

        var gear = [];
        for(var i = 0; i < num_teeth; i++) {
            var theta = i * 2 * Math.PI / num_teeth + theta_cross - dtheta/2;
            var theta2 = i * 2 * Math.PI / num_teeth - theta_cross + dtheta/2;
            for(var j = 0; j < involute.length; j++) {
                gear.push(this.rotate_point([0,0], involute[j], theta));
            }
            for(var j = involute.length - 1; j >= 0; j--) {
                gear.push(this.rotate_point([0,0], [involute[j][0], -involute[j][1]], theta2));
            }
        }
        return gear;
    },

    translate: function(gear, offset) {
        return gear.map(function(p) { return [p[0] + offset[0], p[1] + offset[1]]; });
    },

    rotate: function(gear, angle) {
        var c = Math.cos(angle), s = Math.sin(angle);
        return gear.map(function(p) { return [c*p[0] + s*p[1], -s*p[0] + c*p[1]]; });
    },

    // Generate carrier structure with inner ring, outer gear ring, and spokes
    generateCarrier: function(module, pressure_angle, innerRadius, outerTeeth, spokeCount, spokeWidth) {
        // Inner ring (plain circle)
        var innerRingOuter = innerRadius + 0.8 * module;
        var innerRingInner = innerRadius - 0.8 * module;

        // Outer gear ring
        var outerGear = this.generate(module, pressure_angle, outerTeeth);
        var outerRp = module * outerTeeth / 2.0;
        var outerRootR = outerRp - 1.2 * module;
        var outerRimInner = outerRootR - 1.0 * module;

        return {
            innerRingOuter: innerRingOuter,
            innerRingInner: innerRingInner,
            outerGear: outerGear,
            outerRimInner: outerRimInner,
            spokeCount: spokeCount,
            spokeWidth: spokeWidth
        };
    },

    // Generate internal (ring) gear - normal teeth pointing inward
    generateInternal: function(module, pressure_angle, num_teeth, rim_thickness) {
        // Generate a normal external gear, then flip it so teeth point inward
        var externalGear = this.generate(module, pressure_angle, num_teeth);

        // Find min and max radius of the external gear
        var maxR = 0, minR = Infinity;
        for (var i = 0; i < externalGear.length; i++) {
            var r = this.point_radius(externalGear[i]);
            if (r > maxR) maxR = r;
            if (r < minR) minR = r;
        }

        var Rp = module * num_teeth / 2.0;
        var toothHeight = maxR - minR;

        // Outer rim thickness
        var rimThick = rim_thickness || 2.5 * module;
        var Ro = Rp + rimThick;

        // Inner edge of teeth (tooth roots) - positioned for visual meshing with planets
        // Standard would be Rp + 1.2*module, but we offset slightly inward for better visuals
        var rootR = Rp + 1.0 * module;  // Teeth extend slightly further inward

        // Mirror and offset: flip profile and position so roots are at rootR
        var self = this;
        var internalProfile = externalGear.map(function(p) {
            var r = self.point_radius(p);
            var angle = Math.atan2(p[1], p[0]);
            // Flip: tips become roots, roots become tips
            var flippedR = maxR + minR - r;
            // Offset to position roots at rootR
            var offset = rootR - maxR;
            var newR = flippedR + offset;
            return [newR * Math.cos(angle), newR * Math.sin(angle)];
        });

        return { profile: internalProfile, outerRadius: Ro };
    }
};

// Puzzle configuration
var puzzle = {
    module: 1.0,
    pa: 20 * Math.PI / 180,
    baseSpeed: 0.8,

    // Axles: each has position, array of gear teeth, and mesh info
    // meshParent: which axle this meshes with
    // meshGearIdx: which gear on this axle meshes (0 = first/outer)
    // parentGearIdx: which gear on parent meshes
    axles: []
};

function setupPuzzle() {
    var m = puzzle.module;

    // Helper to calculate mesh distance
    function meshDist(t1, t2) {
        return m * (t1 + t2) / 2;
    }

    // Helper to position gear at angle and distance from another
    function posAt(parent, angle, dist) {
        return [parent[0] + dist * Math.cos(angle), parent[1] + dist * Math.sin(angle)];
    }

    var center = [0, 0];
    var axles = [];

    // Planetary gearset configuration
    var sunTeeth = 12;
    var planetTeeth = 6;
    var ringTeeth = sunTeeth + 2 * planetTeeth;  // Must equal sun + 2*planet for proper mesh
    var numPlanets = 3;
    var gearRatio = sunTeeth / planetTeeth;

    // Carrier outer gear teeth - should be larger than ring gear
    var carrierOuterTeeth = 36;
    var orbitRadius = meshDist(sunTeeth, planetTeeth);

    // Store config for dynamic updates
    puzzle.planetary = {
        sunTeeth: sunTeeth,
        planetTeeth: planetTeeth,
        ringTeeth: ringTeeth,
        gearRatio: gearRatio,
        carrierOuterTeeth: carrierOuterTeeth,
        orbitRadius: orbitRadius
    };

    // Carrier structure (behind everything)
    axles.push({
        id: 'carrier',
        pos: center,
        gears: [carrierOuterTeeth],
        colors: [[180, 130, 70]],  // Orange/bronze - distinct from blue planets
        meshParent: null,
        speedMult: 0,  // Updated dynamically (carrier speed)
        meshDir: -1,  // Negative because orbit uses math convention (CCW+) but gears.rotate uses CW+
        phaseOffset: 0,
        isCarrier: true,
        carrierConfig: {
            innerRadius: orbitRadius,
            spokeCount: numPlanets,
            spokeWidth: 1.5
        },
        zPriority: -10  // Draw behind everything
    });

    // Ring gear (internal teeth)
    axles.push({
        id: 'ring',
        pos: center,
        gears: [ringTeeth],
        colors: [[120, 90, 200]],
        meshParent: null,
        speedMult: 0,  // Updated dynamically
        meshDir: 1,
        phaseOffset: 0,
        isInternal: true,
        zPriority: -1
    });

    // Sun gear (center)
    axles.push({
        id: 'sun',
        pos: center,
        gears: [sunTeeth],
        colors: [[255, 200, 80]],
        meshParent: null,
        speedMult: 1,  // Updated dynamically
        meshDir: 1,
        phaseOffset: 0
    });

    // Planet gears - orbit around sun on carrier
    for (var i = 0; i < numPlanets; i++) {
        var angle = i * 2 * Math.PI / numPlanets;
        axles.push({
            id: 'planet' + i,
            pos: posAt(center, angle, meshDist(sunTeeth, planetTeeth)),
            gears: [planetTeeth],
            colors: [[100, 180, 255]],
            meshParent: 'sun',
            meshGearIdx: 0,
            parentGearIdx: 0,
            speedMult: gearRatio,  // Updated dynamically
            meshDir: -1,
            orbits: 'sun',
            orbitSpeed: 0,  // Updated dynamically
            orbitRadius: meshDist(sunTeeth, planetTeeth),
            orbitPhase: angle
        });
    }

    puzzle.axles = axles;

    // Calculate speed multipliers and mesh phases
    calculateSpeeds();
    calculatePhaseOffsets();

    // Pre-generate gear shapes
    var teethCache = {};
    var internalCache = {};
    puzzle.axles.forEach(function(axle) {
        if (axle.isCarrier) {
            // Carrier structure
            var cfg = axle.carrierConfig;
            axle.carrierShape = gears.generateCarrier(
                puzzle.module, puzzle.pa,
                cfg.innerRadius, axle.gears[0], cfg.spokeCount, cfg.spokeWidth
            );
        } else if (axle.isInternal) {
            // Internal gear - generate ring profile
            axle.gearShapes = axle.gears.map(function(teeth) {
                if (!internalCache[teeth]) {
                    internalCache[teeth] = gears.generateInternal(puzzle.module, puzzle.pa, teeth);
                }
                return internalCache[teeth];
            });
        } else {
            // External gear
            axle.gearShapes = axle.gears.map(function(teeth) {
                if (!teethCache[teeth]) {
                    teethCache[teeth] = gears.generate(puzzle.module, puzzle.pa, teeth);
                }
                return teethCache[teeth];
            });
        }
    });
}

function calculateSpeeds() {
    var axleMap = {};
    puzzle.axles.forEach(function(a) { axleMap[a.id] = a; });

    // Find root axle (no parent, and speedMult not already set)
    var root = puzzle.axles.find(function(a) {
        return a.meshParent === null && a.speedMult === undefined;
    });
    if (!root) return;  // All axles already configured

    var queue = [root.id];
    root.speedMult = 1;
    root.meshDir = 1;
    root.depth = 0;

    while (queue.length > 0) {
        var currentId = queue.shift();
        var current = axleMap[currentId];

        puzzle.axles.forEach(function(axle) {
            if (axle.meshParent === currentId && axle.speedMult === undefined) {
                var parentGearTeeth = current.gears[axle.parentGearIdx];
                var myGearTeeth = axle.gears[axle.meshGearIdx];

                // Speed ratio: my speed = parent speed * (parent teeth / my teeth)
                // Direction reverses at each mesh
                axle.speedMult = current.speedMult * (parentGearTeeth / myGearTeeth);
                axle.meshDir = -current.meshDir;
                axle.depth = current.depth + 1;

                queue.push(axle.id);
            }
        });
    }
}

function calculatePhaseOffsets() {
    var axleMap = {};
    puzzle.axles.forEach(function(a) { axleMap[a.id] = a; });

    // Find root axle (no parent, and phaseOffset not already set)
    var root = puzzle.axles.find(function(a) {
        return a.meshParent === null && a.phaseOffset === undefined;
    });
    if (!root) return;  // All axles already configured

    root.phaseOffset = 0;
    var queue = [root.id];

    while (queue.length > 0) {
        var currentId = queue.shift();
        var parent = axleMap[currentId];

        puzzle.axles.forEach(function(axle) {
            if (axle.meshParent === currentId && axle.phaseOffset === undefined) {
                var parentGearTeeth = parent.gears[axle.parentGearIdx];
                var childGearTeeth = axle.gears[axle.meshGearIdx];

                var dx = axle.pos[0] - parent.pos[0];
                var dy = axle.pos[1] - parent.pos[1];
                var meshAngle = Math.atan2(dy, dx);

                axle.phaseOffset = GearMath.calculateChildPhase(
                    parent.phaseOffset || 0, meshAngle, parentGearTeeth, childGearTeeth
                );

                queue.push(axle.id);
            }
        });
    }
}

// Animation state
var anim = {
    ctx: null,
    baseAngle: 0,
    lastTime: 0
};

function init() {
    setupPuzzle();

    // Calculate bounds to fit all gears
    var minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    puzzle.axles.forEach(function(axle) {
        var maxR = Math.max.apply(null, axle.gears) * puzzle.module / 2 + 1.5 * puzzle.module;
        minX = Math.min(minX, axle.pos[0] - maxR);
        maxX = Math.max(maxX, axle.pos[0] + maxR);
        minY = Math.min(minY, axle.pos[1] - maxR);
        maxY = Math.max(maxY, axle.pos[1] + maxR);
    });

    var margin = 5;
    var canvas = document.getElementById('gear_canvas');
    anim.ctx = graphics.init(canvas, [minX - margin, maxX + margin, minY - margin, maxY + margin]);

    anim.lastTime = performance.now();
    requestAnimationFrame(drawFrame);
}

function drawFrame(timestamp) {
    var dt = (timestamp - anim.lastTime) / 1000;
    anim.lastTime = timestamp;
    anim.baseAngle += puzzle.baseSpeed * dt;

    // Read slider values
    var sunSpeed = parseFloat(document.getElementById('sunSlider').value);
    var carrierSpeed = parseFloat(document.getElementById('carrierSlider').value);
    document.getElementById('sunVal').textContent = sunSpeed.toFixed(2);
    document.getElementById('carrierVal').textContent = carrierSpeed.toFixed(2);

    // Update speeds based on sliders
    var p = puzzle.planetary;
    var ringSpeed = (-p.sunTeeth * sunSpeed - (p.sunTeeth + p.ringTeeth) * carrierSpeed) / p.ringTeeth;

    // Update orbiting gears
    var axleMap = {};
    puzzle.axles.forEach(function(a) { axleMap[a.id] = a; });

    // Apply dynamic speeds
    axleMap['sun'].speedMult = sunSpeed;
    axleMap['ring'].speedMult = ringSpeed;
    axleMap['carrier'].speedMult = carrierSpeed;
    puzzle.axles.forEach(function(axle) {
        if (axle.orbits) {
            axle.speedMult = p.gearRatio * sunSpeed;
            axle.orbitSpeed = carrierSpeed;
        }
    });

    puzzle.axles.forEach(function(axle) {
        if (axle.orbits) {
            var parent = axleMap[axle.orbits];
            var orbitAngle = anim.baseAngle * axle.orbitSpeed + (axle.orbitPhase || 0);
            axle.pos = [
                parent.pos[0] + axle.orbitRadius * Math.cos(orbitAngle),
                parent.pos[1] + axle.orbitRadius * Math.sin(orbitAngle)
            ];
            // Recalculate phase for new mesh angle
            var parentGearTeeth = parent.gears[axle.parentGearIdx];
            var childGearTeeth = axle.gears[axle.meshGearIdx];
            axle.phaseOffset = GearMath.calculateChildPhase(
                parent.phaseOffset || 0, orbitAngle, parentGearTeeth, childGearTeeth
            );
        }
    });

    graphics.clear(anim.ctx);

    // Draw gears back to front: large gears first, small gears on top, zPriority last
    var sortedAxles = puzzle.axles.slice().sort(function(a, b) {
        var zA = a.zPriority || 0;
        var zB = b.zPriority || 0;
        if (zA !== zB) return zA - zB;  // lower zPriority drawn first
        // Sort by largest gear size descending (big gears drawn first/behind)
        return Math.max.apply(null, b.gears) - Math.max.apply(null, a.gears);
    });

    sortedAxles.forEach(function(axle) {
        var rotation = anim.baseAngle * axle.speedMult * axle.meshDir + (axle.phaseOffset || 0);

        if (axle.isCarrier) {
            // Draw carrier structure
            var cs = axle.carrierShape;
            var col = axle.colors[0];
            var ctx = anim.ctx.context;
            var cen = graphics.map_point(anim.ctx, axle.pos);

            // Spoke rotation follows orbit direction (without meshDir)
            var spokeRotation = anim.baseAngle * axle.speedMult;
            var spokeWidth = cs.spokeWidth;
            var halfWidth = spokeWidth / 2;
            var numSpokes = cs.spokeCount;

            // Calculate half-angle of spoke at the outer rim
            var halfSpokeAngle = Math.atan2(halfWidth, cs.outerRimInner);

            // Draw outer gear + spokes as ONE unified shape
            ctx.beginPath();

            // Outer gear profile (rotated with gear teeth rotation for mesh)
            var outerGear = gears.rotate(cs.outerGear, rotation);
            outerGear = gears.translate(outerGear, axle.pos);
            var mappedOuter = outerGear.map(function(p) {
                return graphics.map_point(anim.ctx, p);
            });
            ctx.moveTo(mappedOuter[0][0], mappedOuter[0][1]);
            for (var j = 1; j < mappedOuter.length; j++) {
                ctx.lineTo(mappedOuter[j][0], mappedOuter[j][1]);
            }
            ctx.closePath();

            // Inner cutout: arcs between spokes, with spoke channels extending inward
            var outerRimR = graphics.map_point(anim.ctx, [axle.pos[0] + cs.outerRimInner, axle.pos[1]])[0] - cen[0];
            var innerRingOuterR = graphics.map_point(anim.ctx, [axle.pos[0] + cs.innerRingOuter, axle.pos[1]])[0] - cen[0];

            for (var i = 0; i < numSpokes; i++) {
                var spokeAngle = spokeRotation + i * 2 * Math.PI / numSpokes;
                var nextSpokeAngle = spokeRotation + (i + 1) * 2 * Math.PI / numSpokes;

                // Arc from end of this spoke to start of next spoke (CCW direction for cutout)
                var arcStart = spokeAngle + halfSpokeAngle;
                var arcEnd = nextSpokeAngle - halfSpokeAngle;

                if (i === 0) {
                    // Start at the right edge of first spoke at outer rim
                    var startX = cen[0] + outerRimR * Math.cos(arcStart);
                    var startY = cen[1] + outerRimR * Math.sin(arcStart);
                    ctx.moveTo(startX, startY);
                }

                // Arc between spokes at outer rim radius
                ctx.arc(cen[0], cen[1], outerRimR, arcStart, arcEnd, false);

                // Line inward along left edge of next spoke
                var inX = cen[0] + innerRingOuterR * Math.cos(arcEnd);
                var inY = cen[1] + innerRingOuterR * Math.sin(arcEnd);
                ctx.lineTo(inX, inY);

                // Arc across spoke root at inner ring
                var spokeRootStart = arcEnd;
                var spokeRootEnd = nextSpokeAngle + halfSpokeAngle;
                ctx.arc(cen[0], cen[1], innerRingOuterR, spokeRootStart, spokeRootEnd, false);

                // Line outward along right edge of next spoke
                var outX = cen[0] + outerRimR * Math.cos(spokeRootEnd);
                var outY = cen[1] + outerRimR * Math.sin(spokeRootEnd);
                ctx.lineTo(outX, outY);
            }
            ctx.closePath();

            ctx.fillStyle = graphics.rgb_to_hex(col[0], col[1], col[2]);
            ctx.fill('evenodd');
            ctx.strokeStyle = '#0f0f23';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Draw inner ring (separate shape)
            ctx.beginPath();
            var innerRingInnerR = graphics.map_point(anim.ctx, [axle.pos[0] + cs.innerRingInner, axle.pos[1]])[0] - cen[0];

            ctx.arc(cen[0], cen[1], innerRingOuterR, 0, 2 * Math.PI, false);
            ctx.moveTo(cen[0] + innerRingInnerR, cen[1]);
            ctx.arc(cen[0], cen[1], innerRingInnerR, 0, 2 * Math.PI, true);

            ctx.fillStyle = graphics.rgb_to_hex(col[0], col[1], col[2]);
            ctx.fill('evenodd');
            ctx.strokeStyle = '#0f0f23';
            ctx.lineWidth = 1;
            ctx.stroke();
        } else if (axle.isInternal) {
            // Draw internal (ring) gear
            for (var g = 0; g < axle.gears.length; g++) {
                var shapeData = axle.gearShapes[g];
                var innerProfile = gears.rotate(shapeData.profile, rotation);
                innerProfile = gears.translate(innerProfile, axle.pos);

                var col = axle.colors[g];

                // Draw as ring: outer circle + inner teeth cutout using evenodd
                var ctx = anim.ctx.context;
                ctx.beginPath();

                // Outer circle (clockwise)
                var outerR = shapeData.outerRadius;
                var cen = graphics.map_point(anim.ctx, axle.pos);
                var edge = graphics.map_point(anim.ctx, [axle.pos[0] + outerR, axle.pos[1]]);
                var r = edge[0] - cen[0];
                ctx.arc(cen[0], cen[1], r, 0, 2 * Math.PI, false);

                // Inner profile (counter-clockwise by reversing points)
                var mappedInner = innerProfile.map(function(p) {
                    return graphics.map_point(anim.ctx, p);
                });
                ctx.moveTo(mappedInner[0][0], mappedInner[0][1]);
                for (var j = mappedInner.length - 1; j >= 0; j--) {
                    ctx.lineTo(mappedInner[j][0], mappedInner[j][1]);
                }
                ctx.closePath();

                ctx.fillStyle = graphics.rgb_to_hex(col[0], col[1], col[2]);
                ctx.fill('evenodd');
                ctx.strokeStyle = '#0f0f23';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        } else {
            // Draw external gears
            var gearIndices = [];
            for (var i = 0; i < axle.gears.length; i++) gearIndices.push(i);
            gearIndices.sort(function(a, b) { return axle.gears[b] - axle.gears[a]; });

            for (var gi = 0; gi < gearIndices.length; gi++) {
                var g = gearIndices[gi];
                var shape = gears.rotate(axle.gearShapes[g], rotation);
                shape = gears.translate(shape, axle.pos);

                var col = axle.colors[g];
                graphics.color(anim.ctx, col[0], col[1], col[2]);
                graphics.polyline(anim.ctx, shape, true);
            }
        }
    });

    // Draw axle centers on top
    puzzle.axles.forEach(function(axle) {
        graphics.color(anim.ctx, 30, 30, 50);
        graphics.fillCircle(anim.ctx, axle.pos, 0.8);
    });

    requestAnimationFrame(drawFrame);
}

window.onload = init;
</script>
</body>
</html>
