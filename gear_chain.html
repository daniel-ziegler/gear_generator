<html>
<head>
<title>Gear Puzzle</title>
<style type="text/css">
body {
    margin: 0;
    padding: 0;
    background-color: #1a1a2e;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
}
canvas {
    background-color: #16213e;
}
</style>
</head>
<body>
<canvas id="gear_canvas" width="800" height="800"></canvas>

<script src="gear_math.js"></script>
<script>
// Graphics library
var graphics = {
    component_to_hex: function(c) {
        var hex = Math.floor(c).toString(16);
        return hex.length == 1 ? "0" + hex : hex;
    },

    rgb_to_hex: function(r, g, b) {
        return "#" + this.component_to_hex(r) + this.component_to_hex(g) + this.component_to_hex(b);
    },

    init: function(canvas, bounds) {
        var gctx = {
            canvas: canvas,
            context: canvas.getContext("2d"),
            width: canvas.width,
            height: canvas.height,
            bounds: bounds,
            colour: this.rgb_to_hex(0,0,0)
        };
        return gctx;
    },

    clear: function(gctx) {
        gctx.context.fillStyle = '#16213e';
        gctx.context.fillRect(0, 0, gctx.canvas.width, gctx.canvas.height);
    },

    color: function(gctx, r, g, b) {
        gctx.colour = this.rgb_to_hex(r, g, b);
    },

    map_point: function(gctx, pnt) {
        var scaleX = gctx.width / (gctx.bounds[1] - gctx.bounds[0]);
        var scaleY = gctx.height / (gctx.bounds[3] - gctx.bounds[2]);
        var scale = Math.min(scaleX, scaleY);
        var worldWidth = gctx.bounds[1] - gctx.bounds[0];
        var worldHeight = gctx.bounds[3] - gctx.bounds[2];
        var offsetX = (gctx.width - worldWidth * scale) / 2;
        var offsetY = (gctx.height - worldHeight * scale) / 2;
        return [offsetX + (pnt[0] - gctx.bounds[0]) * scale,
                offsetY + (pnt[1] - gctx.bounds[2]) * scale];
    },

    circle: function(gctx, center, rad) {
        var cen = this.map_point(gctx, center);
        var edge = this.map_point(gctx, [center[0] + rad, center[1]]);
        var r = edge[0] - cen[0];
        gctx.context.beginPath();
        gctx.context.arc(cen[0], cen[1], r, 0, 2 * Math.PI);
        gctx.context.strokeStyle = gctx.colour;
        gctx.context.stroke();
    },

    fillCircle: function(gctx, center, rad) {
        var cen = this.map_point(gctx, center);
        var edge = this.map_point(gctx, [center[0] + rad, center[1]]);
        var r = edge[0] - cen[0];
        gctx.context.beginPath();
        gctx.context.arc(cen[0], cen[1], r, 0, 2 * Math.PI);
        gctx.context.fillStyle = gctx.colour;
        gctx.context.fill();
    },

    text: function(gctx, center, txt, size) {
        var cen = this.map_point(gctx, center);
        var edge = this.map_point(gctx, [center[0] + size, center[1]]);
        var fontSize = (edge[0] - cen[0]) * 1.5;
        gctx.context.font = 'bold ' + fontSize + 'px Arial';
        gctx.context.fillStyle = gctx.colour;
        gctx.context.textAlign = 'center';
        gctx.context.textBaseline = 'middle';
        gctx.context.fillText(txt, cen[0], cen[1]);
    },

    polyline: function(gctx, pnts, close) {
        gctx.context.fillStyle = gctx.colour;
        gctx.context.strokeStyle = '#0f0f23';
        gctx.context.lineWidth = 1;
        gctx.context.beginPath();
        var p = this.map_point(gctx, pnts[0]);
        gctx.context.moveTo(p[0], p[1]);
        for(var i = 1; i < pnts.length; i++) {
            p = this.map_point(gctx, pnts[i]);
            gctx.context.lineTo(p[0], p[1]);
        }
        gctx.context.closePath();
        gctx.context.fill();
        gctx.context.stroke();
    }
};

// Gears library
var gears = {
    point_radius: function(pnt) {
        return Math.sqrt(pnt[0]*pnt[0] + pnt[1]*pnt[1]);
    },

    rotate_point: function(cen, pnt, theta) {
        var tpnt = [pnt[0]-cen[0], pnt[1]-cen[1]];
        var c = Math.cos(theta), s = Math.sin(theta);
        return [c*tpnt[0] + s*tpnt[1] + cen[0], -s*tpnt[0] + c*tpnt[1] + cen[1]];
    },

    involute_point: function(r, theta) {
        return [r*(Math.cos(theta)+theta*Math.sin(theta)),
                -r*(Math.sin(theta)-theta*Math.cos(theta))];
    },

    involute_bisect: function(r_base, r_target) {
        var theta_lo = 0.0, theta_hi = Math.PI;
        for(var i = 0; i < 20; i++) {
            var theta_mi = (theta_lo + theta_hi) / 2.0;
            var r_mi = this.point_radius(this.involute_point(r_base, theta_mi));
            if(r_mi <= r_target) theta_lo = theta_mi;
            else theta_hi = theta_mi;
        }
        return (theta_lo + theta_hi) / 2.0;
    },

    involute_curve: function(r_base, r_min, r_max, N) {
        var theta_hi = this.involute_bisect(r_base, r_max);
        var curve = [];
        if(r_min < r_base) curve.push([r_min, 0]);
        var dtheta = theta_hi / (N - 1);
        for(var i = 0; i < N; i++) {
            curve.push(this.involute_point(r_base, i * dtheta));
        }
        return curve;
    },

    generate: function(module, pressure_angle, num_teeth) {
        var Rp = module * num_teeth / 2.0;
        var Rb = Rp * Math.cos(pressure_angle);
        var Rd = Rp - 1.2 * module;
        var Ra = Rp + 1.0 * module;
        var t = Math.PI * Rp / num_teeth;

        var p_cross = this.involute_point(Rb, this.involute_bisect(Rb, Rp));
        var theta_cross = Math.atan2(p_cross[1], p_cross[0]);
        var dtheta = t / Rp;

        var tmp = this.involute_curve(Rb, Rd, Ra, 20);
        var involute = [];
        for(var i = 0; i < tmp.length; i++) {
            var tpnt = this.rotate_point([0,0], tmp[i], theta_cross - dtheta/2);
            if(Math.atan2(tpnt[1], tpnt[0]) < Math.PI/num_teeth && tpnt[1] > 0) {
                involute.push([tmp[i][0], tmp[i][1]]);
            }
        }

        var gear = [];
        for(var i = 0; i < num_teeth; i++) {
            var theta = i * 2 * Math.PI / num_teeth + theta_cross - dtheta/2;
            var theta2 = i * 2 * Math.PI / num_teeth - theta_cross + dtheta/2;
            for(var j = 0; j < involute.length; j++) {
                gear.push(this.rotate_point([0,0], involute[j], theta));
            }
            for(var j = involute.length - 1; j >= 0; j--) {
                gear.push(this.rotate_point([0,0], [involute[j][0], -involute[j][1]], theta2));
            }
        }
        return gear;
    },

    translate: function(gear, offset) {
        return gear.map(function(p) { return [p[0] + offset[0], p[1] + offset[1]]; });
    },

    rotate: function(gear, angle) {
        var c = Math.cos(angle), s = Math.sin(angle);
        return gear.map(function(p) { return [c*p[0] + s*p[1], -s*p[0] + c*p[1]]; });
    }
};

// Puzzle configuration
var puzzle = {
    module: 1.0,
    pa: 20 * Math.PI / 180,
    baseSpeed: 0.4,

    // Axles: each has position, array of gear teeth, and mesh info
    // meshParent: which axle this meshes with
    // meshGearIdx: which gear on this axle meshes (0 = first/outer)
    // parentGearIdx: which gear on parent meshes
    axles: []
};

function setupPuzzle() {
    var m = puzzle.module;

    // Helper to calculate mesh distance
    function meshDist(t1, t2) {
        return m * (t1 + t2) / 2;
    }

    // Helper to position gear at angle and distance from another
    function posAt(parent, angle, dist) {
        return [parent[0] + dist * Math.cos(angle), parent[1] + dist * Math.sin(angle)];
    }

    var center = [0, 0];
    var axles = [];

    // Center gear: 12 teeth
    axles.push({
        id: 'center',
        pos: center,
        gears: [12],
        colors: [[255, 100, 100]],
        meshParent: null,
        speedMult: 1
    });

    // Branch 0: Simple gear at 30째 (ratio 1.5)
    var ang0 = 30 * Math.PI / 180;
    axles.push({
        id: 'b0',
        pos: posAt(center, ang0, meshDist(12, 18)),
        gears: [18],
        colors: [[255, 160, 80]],
        meshParent: 'center',
        meshGearIdx: 0,
        parentGearIdx: 0,
        isTerminal: true
    });

    // Branch 1: Compound gear at 120째 - intermediate(20) meshes center, output(8) drives terminal
    var ang1 = 120 * Math.PI / 180;
    var b1_pos = posAt(center, ang1, meshDist(12, 20));
    axles.push({
        id: 'b1_compound',
        pos: b1_pos,
        gears: [20, 8],  // 20 meshes with center, 8 is output
        colors: [[80, 200, 80], [60, 160, 60]],
        meshParent: 'center',
        meshGearIdx: 0,
        parentGearIdx: 0
    });

    // Terminal gear driven by compound's output gear
    var ang1_out = 120 * Math.PI / 180 + 0.6;  // Offset angle from compound
    var b1_term_pos = posAt(b1_pos, ang1_out, meshDist(8, 16));
    axles.push({
        id: 'b1_term',
        pos: b1_term_pos,
        gears: [16],
        colors: [[100, 255, 100]],
        meshParent: 'b1_compound',
        meshGearIdx: 0,
        parentGearIdx: 1,  // Meshes with the 8-tooth output gear
        isTerminal: true
    });

    // Branch 2: Simple gear at 210째 (ratio 2.0)
    var ang2 = 210 * Math.PI / 180;
    axles.push({
        id: 'b2',
        pos: posAt(center, ang2, meshDist(12, 24)),
        gears: [24],
        colors: [[80, 150, 255]],
        meshParent: 'center',
        meshGearIdx: 0,
        parentGearIdx: 0,
        isTerminal: true
    });

    // Branch 3: Compound gear at 300째 - intermediate(15) meshes center, output(10) drives terminal
    var ang3 = 300 * Math.PI / 180;
    var b3_pos = posAt(center, ang3, meshDist(12, 15));
    axles.push({
        id: 'b3_compound',
        pos: b3_pos,
        gears: [15, 10],
        colors: [[200, 80, 200], [160, 60, 160]],
        meshParent: 'center',
        meshGearIdx: 0,
        parentGearIdx: 0
    });

    var ang3_out = 300 * Math.PI / 180 - 0.5;
    var b3_term_pos = posAt(b3_pos, ang3_out, meshDist(10, 25));
    axles.push({
        id: 'b3_term',
        pos: b3_term_pos,
        gears: [25],
        colors: [[255, 120, 255]],
        meshParent: 'b3_compound',
        meshGearIdx: 0,
        parentGearIdx: 1,
        isTerminal: true,
        zPriority: 1
    });

    puzzle.axles = axles;

    // Calculate speed multipliers and mesh phases
    calculateSpeeds();
    calculatePhaseOffsets();

    // Pre-generate gear shapes
    var teethCache = {};
    puzzle.axles.forEach(function(axle) {
        axle.gearShapes = axle.gears.map(function(teeth) {
            if (!teethCache[teeth]) {
                teethCache[teeth] = gears.generate(puzzle.module, puzzle.pa, teeth);
            }
            return teethCache[teeth];
        });
    });
}

function calculateSpeeds() {
    var axleMap = {};
    puzzle.axles.forEach(function(a) { axleMap[a.id] = a; });

    // BFS from center to calculate speed multipliers and mesh directions
    var queue = ['center'];
    axleMap['center'].speedMult = 1;
    axleMap['center'].meshDir = 1;
    axleMap['center'].depth = 0;

    while (queue.length > 0) {
        var currentId = queue.shift();
        var current = axleMap[currentId];

        puzzle.axles.forEach(function(axle) {
            if (axle.meshParent === currentId && axle.speedMult === undefined) {
                var parentGearTeeth = current.gears[axle.parentGearIdx];
                var myGearTeeth = axle.gears[axle.meshGearIdx];

                // Speed ratio: my speed = parent speed * (parent teeth / my teeth)
                // Direction reverses at each mesh
                axle.speedMult = current.speedMult * (parentGearTeeth / myGearTeeth);
                axle.meshDir = -current.meshDir;
                axle.depth = current.depth + 1;

                queue.push(axle.id);
            }
        });
    }
}

function calculatePhaseOffsets() {
    var axleMap = {};
    puzzle.axles.forEach(function(a) { axleMap[a.id] = a; });

    axleMap['center'].phaseOffset = 0;

    // BFS from center to compute phase offsets
    var queue = ['center'];

    while (queue.length > 0) {
        var currentId = queue.shift();
        var parent = axleMap[currentId];

        puzzle.axles.forEach(function(axle) {
            if (axle.meshParent === currentId && axle.phaseOffset === undefined) {
                var parentGearTeeth = parent.gears[axle.parentGearIdx];
                var childGearTeeth = axle.gears[axle.meshGearIdx];

                var dx = axle.pos[0] - parent.pos[0];
                var dy = axle.pos[1] - parent.pos[1];
                var meshAngle = Math.atan2(dy, dx);

                axle.phaseOffset = GearMath.calculateChildPhase(
                    parent.phaseOffset || 0, meshAngle, parentGearTeeth, childGearTeeth
                );

                queue.push(axle.id);
            }
        });
    }
}

// Animation state
var anim = {
    ctx: null,
    baseAngle: 0,
    lastTime: 0
};

function init() {
    setupPuzzle();

    // Calculate bounds to fit all gears
    var minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    puzzle.axles.forEach(function(axle) {
        var maxR = Math.max.apply(null, axle.gears) * puzzle.module / 2 + puzzle.module;
        minX = Math.min(minX, axle.pos[0] - maxR);
        maxX = Math.max(maxX, axle.pos[0] + maxR);
        minY = Math.min(minY, axle.pos[1] - maxR);
        maxY = Math.max(maxY, axle.pos[1] + maxR);
    });

    var margin = 5;
    var canvas = document.getElementById('gear_canvas');
    anim.ctx = graphics.init(canvas, [minX - margin, maxX + margin, minY - margin, maxY + margin]);

    anim.lastTime = performance.now();
    requestAnimationFrame(drawFrame);
}

function drawFrame(timestamp) {
    var dt = (timestamp - anim.lastTime) / 1000;
    anim.lastTime = timestamp;
    anim.baseAngle += puzzle.baseSpeed * dt;

    graphics.clear(anim.ctx);

    // Draw gears back to front: large gears first, small gears on top, zPriority last
    var sortedAxles = puzzle.axles.slice().sort(function(a, b) {
        var zA = a.zPriority || 0;
        var zB = b.zPriority || 0;
        if (zA !== zB) return zA - zB;  // lower zPriority drawn first
        // Sort by largest gear size descending (big gears drawn first/behind)
        return Math.max.apply(null, b.gears) - Math.max.apply(null, a.gears);
    });

    sortedAxles.forEach(function(axle) {
        var rotation = anim.baseAngle * axle.speedMult * axle.meshDir + (axle.phaseOffset || 0);

        // Draw gears on this axle: largest first, smallest on top
        var gearIndices = [];
        for (var i = 0; i < axle.gears.length; i++) gearIndices.push(i);
        gearIndices.sort(function(a, b) { return axle.gears[b] - axle.gears[a]; });

        for (var gi = 0; gi < gearIndices.length; gi++) {
            var g = gearIndices[gi];
            var shape = gears.rotate(axle.gearShapes[g], rotation);
            shape = gears.translate(shape, axle.pos);

            var col = axle.colors[g];
            graphics.color(anim.ctx, col[0], col[1], col[2]);
            graphics.polyline(anim.ctx, shape, true);
        }
    });

    // Draw axle centers on top
    puzzle.axles.forEach(function(axle) {
        graphics.color(anim.ctx, 30, 30, 50);
        graphics.fillCircle(anim.ctx, axle.pos, 0.8);
    });

    // Draw "1" label inside center gear, rotating with it
    var centerAxle = puzzle.axles.find(function(a) { return a.id === 'center'; });
    var centerRotation = anim.baseAngle * centerAxle.speedMult * centerAxle.meshDir;
    var cen = graphics.map_point(anim.ctx, centerAxle.pos);

    graphics.color(anim.ctx, 255, 255, 255);
    graphics.fillCircle(anim.ctx, centerAxle.pos, 1.2);

    // Rotate text with gear
    anim.ctx.context.save();
    anim.ctx.context.translate(cen[0], cen[1]);
    anim.ctx.context.rotate(-centerRotation);
    anim.ctx.context.font = 'bold 20px Arial';
    anim.ctx.context.fillStyle = '#000';
    anim.ctx.context.textAlign = 'center';
    anim.ctx.context.textBaseline = 'middle';
    anim.ctx.context.fillText('1', 0, 0);
    anim.ctx.context.restore();

    // Draw branch number labels inside terminal/leaf gears, rotating with them
    puzzle.axles.forEach(function(axle) {
        if (!axle.isTerminal) return;

        var rotation = anim.baseAngle * axle.speedMult * axle.meshDir + (axle.phaseOffset || 0);
        var pos = graphics.map_point(anim.ctx, axle.pos);

        graphics.color(anim.ctx, 255, 255, 255);
        graphics.fillCircle(anim.ctx, axle.pos, 2.0);

        // Extract branch number from id (e.g., 'b0' -> '0')
        var branchNum = axle.id.replace('b', '');

        anim.ctx.context.save();
        anim.ctx.context.translate(pos[0], pos[1]);
        anim.ctx.context.rotate(-rotation);
        anim.ctx.context.font = 'bold 28px Arial';
        anim.ctx.context.fillStyle = '#000';
        anim.ctx.context.textAlign = 'center';
        anim.ctx.context.textBaseline = 'middle';
        anim.ctx.context.fillText(branchNum, 0, 0);
        anim.ctx.context.restore();
    });

    requestAnimationFrame(drawFrame);
}

window.onload = init;
</script>
</body>
</html>
